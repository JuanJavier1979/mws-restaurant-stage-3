{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","Promise","response","status","resolve","reject","Error","statusText","json","idb","open","upgradeDb","oldVersion","dbPromise","console","createObjectStore","keyPath","store","createIndex","reviews","offlineReviews","openDB","then","db","transaction","objectStore","getAll","fetch","DATABASE_URL","checkStatus","restaurants","saveRestaurants","data","tx","forEach","restaurant","put","log","length","getRestaurantsFromAPI","callback","catch","error","id","fetchRestaurants","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","fetchReviews","cuisines","uniqueCuisines","arguments","undefined","imgWidth","imageUrlForRestaurant","google","maps","position","latlng","url","urlForRestaurant","animation","Animation","DROP","index","REVIEWS_URL","saveReviews","err","review","complete","marker","reviewsFromDB","detail","restaurant_id","document","dispatchEvent","event","reviewsFromAPI","body","JSON","stringify","headers","Accept","Content-Type","parseInt","getParameterByName","Date","getTime","saveReview","saveReviewOffline","requests","iterateCursor","cursor","sendReview","value","push","delete","continue","getReviewsFromDB","getReviewsFromAPI","obj","favourite_status","method","updateRestaurant","sendFavourite","is_favorite"],"mappings":"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","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Get Reviews Endpoint.\r\n   */\r\n  static get REVIEWS_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/reviews`;\r\n  }\r\n\r\n  /**\r\n   * Check status of Fetch requests.\r\n   */\r\n  static checkStatus(response) {\r\n    if (response.status === 200) {\r\n      return Promise.resolve(response)\r\n    } else {\r\n      return Promise.reject(new Error(`Request has failed. Return status: ${response.statusText}`))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert response to JSON data.\r\n   */\r\n  static json(response) {\r\n    return response.json()\r\n  }\r\n\r\n  /**\r\n   * Opens the IndexedDB.\r\n   */\r\n  static openDB() {\r\n    const dbPromise = idb.open('restaurantsDB', 3, upgradeDb => {\r\n      switch (upgradeDb.oldVersion) {\r\n        case 0:\r\n          console.log('Creating IDB');\r\n          const store = upgradeDb.createObjectStore('restaurants', {keyPath: 'id'});\r\n          store.createIndex('by-id', 'id');\r\n        case 1:\r\n          console.log(\"Upgrading to DB v2\");\r\n          const reviews = upgradeDb.createObjectStore('reviews', {keyPath: 'id'});\r\n          reviews.createIndex('restaurant','restaurant_id');\r\n          const offlineReviews = upgradeDb.createObjectStore('offline_reviews', {keyPath: 'updatedAt'});\r\n        case 2:\r\n          console.log(\"Upgrading to DB v3\");\r\n          const offlineFavourites = upgradeDb.createObjectStore('offline_favourites', {keyPath: 'restaurant_id'});\r\n          offlineFavourites.createIndex('by-restaurant', 'restaurant_id');\r\n      }\r\n    });\r\n    return dbPromise;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the IDB.\r\n   */\r\n  static getRestaurantsFromDB() {\r\n    const restaurantsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('restaurants').objectStore('restaurants');\r\n      return store.getAll();\r\n    });\r\n    return restaurantsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the Server API.\r\n   */\r\n  static getRestaurantsFromAPI(){\r\n    const restaurantsFromAPI = fetch(DBHelper.DATABASE_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(restaurants => {\r\n      DBHelper.saveRestaurants(restaurants);\r\n      return restaurants;\r\n    });\r\n    return restaurantsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Save restaurants data to IDB.\r\n   */\r\n  static saveRestaurants(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      data.forEach((restaurant) => {\r\n        store.put(restaurant);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Restaurants Saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update restaurant data to IDB.\r\n   */\r\n  static updateRestaurant(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      return store.put(data);\r\n    }).then(() => {\r\n      console.log('Restaurant Updated')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    return DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n      if(restaurants.length) {\r\n        return Promise.resolve(restaurants);\r\n      } else {\r\n        return DBHelper.getRestaurantsFromAPI();\r\n      }\r\n    }).then(restaurants => {\r\n      callback(null, restaurants);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n    DBHelper.fetchReviews((error, reviews) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        console.log('dbhelper fetchReviews !error()')\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant, imgWidth = null) {\r\n    if (imgWidth !== null) {\r\n      return `/build/img/${restaurant.id}-${imgWidth}.jpg`;\r\n    }\r\n    return `/build/img/${restaurant.id}-original.jpg`;\r\n  }\r\n\r\n  /**\r\n   * Restaurant image SRCSET.\r\n   */\r\n  static imageSrcSetForRestaurant(restaurant) {\r\n    const widthXsmall   = DBHelper.imageUrlForRestaurant(restaurant, 'xsmall');\r\n    const widthSmall    = DBHelper.imageUrlForRestaurant(restaurant, 'small');\r\n    const widthMedium   = DBHelper.imageUrlForRestaurant(restaurant, 'medium');\r\n    const widthLarge    = DBHelper.imageUrlForRestaurant(restaurant, 'large');\r\n    const widthOriginal = DBHelper.imageUrlForRestaurant(restaurant);\r\n    const imageSrcSet = `${widthXsmall} 360w, ${widthSmall} 520w, ${widthMedium} 800w, ${widthLarge} 1000w, ${widthOriginal} 1500w`;\r\n    return imageSrcSet;\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    //return marker;\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the IDB.\r\n   */\r\n  static getReviewsFromDB() {\r\n    const reviewsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('reviews').objectStore('reviews').index('restaurant');\r\n      return '';//store.getAll();\r\n    });\r\n    return reviewsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the Server API.\r\n   */\r\n  static getReviewsFromAPI(){\r\n    const reviewsFromAPI = fetch(DBHelper.REVIEWS_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(reviews => {\r\n      DBHelper.saveReviews(reviews);\r\n      return reviews;\r\n    });\r\n    return reviewsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews saved as Offline.\r\n   */\r\n  static checkOfflineReviews(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_reviews').objectStore('offline_reviews');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Save Reviews data to IDB.\r\n   */\r\n  static saveReviews(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      data.forEach((review) => {\r\n        store.put(review);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Reviews saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB.\r\n   */\r\n  static saveReview(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved')\r\n      let event = new CustomEvent(\"update_reviews_list\", {detail: {restaurant_id: data.restaurant_id}});\r\n      document.dispatchEvent(event);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB's offline store.\r\n   */\r\n  static saveReviewOffline(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_reviews', 'readwrite');\r\n      const store = tx.objectStore('offline_reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendReview(data) {\r\n    return fetch(DBHelper.REVIEWS_URL, {\r\n      body: JSON.stringify(data),\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': 'application/json'\r\n      },\r\n      method: 'POST',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n        data['updatedAt'] = new Date().getTime();\r\n        data['createdAt'] = new Date().getTime();\r\n        DBHelper.saveReview(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n      data['updatedAt'] = new Date().getTime();\r\n      data['createdAt'] = new Date().getTime();\r\n      DBHelper.saveReviewOffline(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Reviews and send them to server.\r\n   */\r\n  static removeOfflineReview(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_reviews', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_reviews')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendReview(cursor.value)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Item deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch all reviews.\r\n   */\r\n  static fetchReviews(callback) {\r\n    return DBHelper.getReviewsFromDB().then(reviews => {\r\n      if(reviews.length) {\r\n        return Promise.resolve(reviews);\r\n      } else {\r\n        return DBHelper.getReviewsFromAPI();\r\n      }\r\n    }).then(reviews => {\r\n      callback(null, reviews);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews by its ID.\r\n   */\r\n  static fetchReviewByRestaurant(id, callback) {\r\n    return DBHelper.openDB().then(db => {\r\n      return db.transaction('reviews').objectStore('reviews').index('restaurant').getAll(id);\r\n    }).then(obj => {\r\n      return obj\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Favourite data to IDB's offline store.\r\n   */\r\n  static saveFavouriteOffline(id, favourite_status){\r\n    const data = []\r\n    data['restaurant_id'] = parseInt(id);\r\n    data['is_favorite'] = favourite_status;\r\n\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_favourites', 'readwrite');\r\n      const store = tx.objectStore('offline_favourites');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Favourite saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendFavourite(id, favourite_status) {\r\n    let UPDATE_FAV_URL = `${DBHelper.DATABASE_URL}/${id}/?is_favorite=${favourite_status}`\r\n\r\n    return fetch(UPDATE_FAV_URL, {\r\n      method: 'PUT',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        DBHelper.updateRestaurant(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      DBHelper.saveFavouriteOffline(id, favourite_status);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the Favourites saved as Offline.\r\n   */\r\n  static checkOfflineFavourites(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_favourites').objectStore('offline_favourites');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Favourites and send them to server.\r\n   */\r\n  static removeOfflineFavourite(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_favourites', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_favourites')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendFavourite(cursor.value.restaurant_id, cursor.value.is_favorite)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Favourite deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n}\r\n"]}