{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","Promise","response","status","resolve","reject","Error","statusText","json","idb","open","upgradeDb","oldVersion","dbPromise","console","createObjectStore","keyPath","store","createIndex","openDB","then","db","transaction","objectStore","getAll","fetch","DATABASE_URL","checkStatus","restaurants","saveRestaurants","data","tx","forEach","restaurant","put","callback","getRestaurantsFromDB","length","getRestaurantsFromAPI","catch","error","id","find","r","fetchRestaurants","results","filter","cuisine_type","cuisine","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","reviews","log","cuisines","uniqueCuisines","arguments","undefined","imgWidth","imageUrlForRestaurant","google","maps","Marker","latlng","title","name","url","urlForRestaurant","animation","index","REVIEWS_URL","saveReviews","widthXsmall","widthSmall","review","marker","reviewsFromDB","reviewsFromAPI","body","JSON","stringify","headers","Accept","Content-Type","method","parseInt","getParameterByName","Date","getTime","saveReview","saveReviewOffline","complete","requests","iterateCursor","cursor","sendReview","value","push","delete","continue","getReviewsFromDB","getReviewsFromAPI","obj"],"mappings":"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","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Get Reviews Endpoint.\r\n   */\r\n  static get REVIEWS_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/reviews`;\r\n  }\r\n\r\n  /**\r\n   * Check status of Fetch requests.\r\n   */\r\n  static checkStatus(response) {\r\n    if (response.status === 200) {\r\n      return Promise.resolve(response)\r\n    } else {\r\n      return Promise.reject(new Error(`Request has failed. Return status: ${response.statusText}`))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert response to JSON data\r\n   */\r\n  static json(response) {\r\n    return response.json()\r\n  }\r\n\r\n  /**\r\n   * Opens the IndexedDB\r\n   */\r\n  static openDB() {\r\n    const dbPromise = idb.open('restaurantsDB', 2, upgradeDb => {\r\n      switch (upgradeDb.oldVersion) {\r\n        case 0:\r\n          console.log('Creating IDB');\r\n          const store = upgradeDb.createObjectStore('restaurants', {keyPath: 'id'});\r\n          store.createIndex('by-id', 'id');\r\n        case 1:\r\n          console.log(\"Upgrading to DB v2\");\r\n          const reviews = upgradeDb.createObjectStore('reviews', {keyPath: 'id'});\r\n          reviews.createIndex('restaurant','restaurant_id');\r\n          const offlineReviews = upgradeDb.createObjectStore('offline_reviews', {keyPath: 'updatedAt'});\r\n      }\r\n    });\r\n    return dbPromise;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the IDB\r\n   */\r\n  static getRestaurantsFromDB() {\r\n    const restaurantsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('restaurants').objectStore('restaurants');\r\n      return store.getAll();\r\n    });\r\n    return restaurantsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the Server API\r\n   */\r\n  static getRestaurantsFromAPI(){\r\n    const restaurantsFromAPI = fetch(DBHelper.DATABASE_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(restaurants => {\r\n      DBHelper.saveRestaurants(restaurants);\r\n      return restaurants;\r\n    });\r\n    return restaurantsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Save restaurant data to IDB\r\n   */\r\n  static saveRestaurants(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      data.forEach((restaurant) => {\r\n        store.put(restaurant);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Restaurants Saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    return DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n      if(restaurants.length) {\r\n        return Promise.resolve(restaurants);\r\n      } else {\r\n        return DBHelper.getRestaurantsFromAPI();\r\n      }\r\n    }).then(restaurants => {\r\n      callback(null, restaurants);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n    DBHelper.fetchReviews((error, reviews) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        console.log('dbhelper fetchReviews !error()')\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant, imgWidth = null) {\r\n    if (imgWidth !== null) {\r\n      return `/build/img/${restaurant.id}-${imgWidth}.jpg`;\r\n    }\r\n    return `/build/img/${restaurant.id}-original.jpg`;\r\n  }\r\n\r\n  /**\r\n   * Restaurant image SRCSET.\r\n   */\r\n  static imageSrcSetForRestaurant(restaurant) {\r\n    const widthXsmall   = DBHelper.imageUrlForRestaurant(restaurant, 'xsmall');\r\n    const widthSmall    = DBHelper.imageUrlForRestaurant(restaurant, 'small');\r\n    const widthMedium   = DBHelper.imageUrlForRestaurant(restaurant, 'medium');\r\n    const widthLarge    = DBHelper.imageUrlForRestaurant(restaurant, 'large');\r\n    const widthOriginal = DBHelper.imageUrlForRestaurant(restaurant);\r\n    const imageSrcSet = `${widthXsmall} 360w, ${widthSmall} 520w, ${widthMedium} 800w, ${widthLarge} 1000w, ${widthOriginal} 1500w`;\r\n    return imageSrcSet;\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    //return marker;\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the IDB\r\n   */\r\n  static getReviewsFromDB() {\r\n    const reviewsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('reviews').objectStore('reviews').index('restaurant');//?\r\n      return '';//store.getAll();\r\n    });\r\n    return reviewsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the Server API\r\n   */\r\n  static getReviewsFromAPI(){\r\n    const reviewsFromAPI = fetch(DBHelper.REVIEWS_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(reviews => {\r\n      DBHelper.saveReviews(reviews);\r\n      return reviews;\r\n    });\r\n    return reviewsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews saved as Offline\r\n   */\r\n  static checkOfflineReviews(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_reviews').objectStore('offline_reviews');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Save Reviews data to IDB\r\n   */\r\n  static saveReviews(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      data.forEach((review) => {\r\n        store.put(review);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Reviews saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB\r\n   */\r\n  static saveReview(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB's offline store\r\n   */\r\n  static saveReviewOffline(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_reviews', 'readwrite');\r\n      const store = tx.objectStore('offline_reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendReview(data) {\r\n    return fetch(DBHelper.REVIEWS_URL, {\r\n      body: JSON.stringify(data),\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': 'application/json'\r\n      },\r\n      method: 'POST',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n        data['updatedAt'] = new Date().getTime();\r\n        data['createdAt'] = new Date().getTime();\r\n        console.log('review SENT!')\r\n        DBHelper.saveReview(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n      data['updatedAt'] = new Date().getTime();\r\n      data['createdAt'] = new Date().getTime();\r\n      DBHelper.saveReviewOffline(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Reviews and send them to server.\r\n   */\r\n  static removeOfflineReview(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_reviews', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_reviews')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendReview(cursor.value)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Item deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch all reviews.\r\n   */\r\n  static fetchReviews(callback) {\r\n    return DBHelper.getReviewsFromDB().then(reviews => {\r\n      if(reviews.length) {\r\n        return Promise.resolve(reviews);\r\n      } else {\r\n        return DBHelper.getReviewsFromAPI();\r\n      }\r\n    }).then(reviews => {\r\n      callback(null, reviews);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews by its ID.\r\n   */\r\n  static fetchReviewByRestaurant(id, callback) {\r\n    return DBHelper.openDB().then(db => {\r\n      return db.transaction('reviews').objectStore('reviews').index('restaurant').getAll(id);\r\n    }).then(obj => {\r\n      return obj\r\n    });\r\n  }\r\n\r\n}\r\n"]}